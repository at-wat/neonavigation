/*
 * Copyright (c) 2024, the neonavigation authors
 * All rights reserved.
 */

#include <algorithm>
#include <vector>
#include <cmath>

#include <planner_cspace/cyclic_vec.h>
#include <planner_cspace/planner_3d/motion_primitive_builder.h>
#include <costmap_cspace_msgs/MapMetaData3D.h>

#include <gtest/gtest.h>

#include <planner_cspace/planner_3d/motion_cache.h>
#include <planner_cspace/blockmem_gridmap.h>

namespace planner_cspace
{
namespace planner_3d
{
using Vec = MotionPrimitiveBuilder::Vec;

TEST(MotionPrimitiveBuilder, BezierSanity)
{
  costmap_cspace_msgs::MapMetaData3D map_info;
  map_info.linear_resolution = 0.1f;
  map_info.angular_resolution = static_cast<float>(M_PI / 8);
  map_info.angle = 16;

  CostCoeff cc;
  cc.min_curve_radius_ = 0.5f;
  cc.motion_primitive_type_ = MotionPrimitiveType::BEZIER;
  cc.bezier_cp_dist_ = 0.5f;
  cc.angle_resolution_aspect_ = 2.0f / tanf(map_info.angular_resolution);

  const int range = 4;
  const auto motion_primitives = MotionPrimitiveBuilder::build(map_info, cc, range);

  ASSERT_EQ(map_info.angle, motion_primitives.size());

  bool found_forward = false;
  bool found_backward = false;
  bool found_rotation = false;

  for (size_t i = 0; i < motion_primitives.size(); ++i)
  {
    for (const auto& prim : motion_primitives[i])
    {
      if (prim[0] == 0 && prim[1] == 0)
      {
        if (prim[2] != 0)
          found_rotation = true;
      }
      else
      {
        // For i=0, forward is prim[0] > 0
        if (i == 0)
        {
          if (prim[0] > 0)
            found_forward = true;
          if (prim[0] < 0)
            found_backward = true;
        }
      }
    }
  }

  EXPECT_TRUE(found_forward) << "No forward primitives found in Bezier mode";
  EXPECT_TRUE(found_backward) << "No backward primitives found in Bezier mode (Fix verified)";
  EXPECT_TRUE(found_rotation) << "No rotation primitives found in Bezier mode";
}

TEST(MotionPrimitiveBuilder, NoOpExclusion)
{
  costmap_cspace_msgs::MapMetaData3D map_info;
  map_info.linear_resolution = 0.1f;
  map_info.angular_resolution = static_cast<float>(M_PI / 8);
  map_info.angle = 16;
  CostCoeff cc;
  cc.min_curve_radius_ = 0.5f;
  cc.bezier_cp_dist_ = 0.5f;
  cc.angle_resolution_aspect_ = 2.0f / tanf(map_info.angular_resolution);
  const int range = 8;

  // Test both modes
  for (auto type : {MotionPrimitiveType::DEFAULT, MotionPrimitiveType::BEZIER})
  {
    cc.motion_primitive_type_ = type;
    const auto motion_primitives = MotionPrimitiveBuilder::build(map_info, cc, range);
    for (size_t i = 0; i < motion_primitives.size(); ++i)
    {
      for (const auto& prim : motion_primitives[i])
      {
        EXPECT_FALSE(prim[0] == 0 && prim[1] == 0 && prim[2] == 0)
            << "No-op primitive (0,0,0) found in " << (type == MotionPrimitiveType::BEZIER ? "BEZIER" : "DEFAULT")
            << " mode at yaw index " << i;
      }
    }
  }
}

TEST(MotionPrimitiveBuilder, BezierLaneChange)
{
  costmap_cspace_msgs::MapMetaData3D map_info;
  map_info.linear_resolution = 0.1f;
  map_info.angular_resolution = static_cast<float>(M_PI / 8);
  map_info.angle = 16;

  CostCoeff cc;
  cc.min_curve_radius_ = 0.3f;  // Loose enough for lane change
  cc.motion_primitive_type_ = MotionPrimitiveType::BEZIER;
  cc.bezier_cp_dist_ = 0.5f;
  cc.angle_resolution_aspect_ = 10.0f;

  const int range = 8;
  const auto motion_primitives = MotionPrimitiveBuilder::build(map_info, cc, range);

  // Look for a primitive with x=7, y=1, yaw=0 relative to start yaw 0
  bool found_lane_change = false;
  for (const auto& prim : motion_primitives[0])
  {
    if (prim[0] == 7 && prim[1] == 1 && prim[2] == 0)
    {
      found_lane_change = true;
      break;
    }
  }
  EXPECT_TRUE(found_lane_change) << "Lane change primitive (7, 1, 0) not generated by buildBezier";

  // Verify MotionCache interpolation for this primitive
  BlockMemGridmap<char, 3, 2, 0x20> gm;
  MotionCache cache;
  cache.reset(
      map_info.linear_resolution, map_info.angular_resolution, range,
      gm.getAddressor(), 0.05, 0.1,
      MotionPrimitiveType::BEZIER, cc.bezier_cp_dist_);

  const auto it = cache.find(0, CyclicVecInt<3, 2>(7, 1, 0));
  ASSERT_NE(it, cache.end(0)) << "Lane change primitive not found in MotionCache";

  const auto& path = it->second.getInterpolatedMotion();
  ASSERT_GE(path.size(), 3);

  // For a straight line (0,0)->(7.0, 1.0), the middle point would be (3.5, 0.5)
  // The curvature should make it S-shaped.
  // Actually, for a symmetrical lane change, the middle point IS on the line,
  // but the headings and intermediate points before/after will be different.

  // In grid: y_grid = 0.156.
  // Straight line y_grid at x=1.75 is 0.25.
  // Difference is clear.

  bool is_curved = false;
  for (const auto& p : path)
  {
    if (p[0] > 1.0 && p[0] < 3.0)
    {
      float expected_straight_y = p[0] * (1.0 / 7.0);
      if (std::abs(p[1] - expected_straight_y) > 0.05)
      {
        is_curved = true;
      }
    }
  }
  EXPECT_TRUE(is_curved) << "Bezier path for lane change is too close to a straight line";
}

TEST(MotionPrimitiveBuilder, BezierUniformSpacing)
{
  costmap_cspace_msgs::MapMetaData3D map_info;
  map_info.linear_resolution = 0.1f;
  map_info.angular_resolution = static_cast<float>(M_PI / 8);
  map_info.angle = 16;

  const int range = 8;
  BlockMemGridmap<char, 3, 2, 0x20> gm;
  MotionCache cache;
  const float bezier_cp_dist = 0.5f;
  cache.reset(
      map_info.linear_resolution, map_info.angular_resolution, range,
      gm.getAddressor(), 0.05, 0.1,
      MotionPrimitiveType::BEZIER, bezier_cp_dist);

  // Check a lane-change primitive (7, 1, 0)
  const auto it = cache.find(0, CyclicVecInt<3, 2>(7, 1, 0));
  ASSERT_NE(it, cache.end(0));

  const auto& path = it->second.getInterpolatedMotion();
  ASSERT_GE(path.size(), 5);

  std::vector<float> step_distances;
  float sum_dist = 0;
  for (size_t i = 1; i < path.size(); ++i)
  {
    float d = (path[i] - path[i - 1]).len();
    step_distances.push_back(d);
    sum_dist += d;
  }

  float avg_dist = sum_dist / step_distances.size();
  float sum_sq_diff = 0;
  for (float d : step_distances)
  {
    sum_sq_diff += std::pow(d - avg_dist, 2);
  }
  float std_dev = std::sqrt(sum_sq_diff / step_distances.size());

  // With uniform arc length sampling, the standard deviation should be very small.
  // We use grid coords, so there might be slight float variations, but it should be < 0.01
  EXPECT_LT(std_dev, 0.01) << "Bezier steps are not uniform. StdDev: " << std_dev;

  // For comparison, let's just log the distances
  // for(float d : step_distances) std::cout << d << ", ";
  // std::cout << std::endl;
}

TEST(MotionPrimitiveBuilder, BezierCurvature)
{
  costmap_cspace_msgs::MapMetaData3D map_info;
  map_info.linear_resolution = 0.1f;
  map_info.angular_resolution = static_cast<float>(M_PI / 8);
  map_info.angle = 16;

  CostCoeff cc;
  cc.motion_primitive_type_ = MotionPrimitiveType::BEZIER;
  cc.bezier_cp_dist_ = 0.5f;
  cc.angle_resolution_aspect_ = 10.0f;

  const int range = 8;

  // With a very large min_curve_radius, only straight lines and rotations should remain
  cc.min_curve_radius_ = 100.0f;
  auto prims_tight = MotionPrimitiveBuilder::build(map_info, cc, range);

  // With a small min_curve_radius, many more primitives should be valid
  cc.min_curve_radius_ = 0.1f;
  auto prims_loose = MotionPrimitiveBuilder::build(map_info, cc, range);

  size_t count_tight = 0;
  for (const auto& v : prims_tight)
    count_tight += v.size();

  size_t count_loose = 0;
  for (const auto& v : prims_loose)
    count_loose += v.size();

  EXPECT_GT(count_loose, count_tight);
}

}  // namespace planner_3d
}  // namespace planner_cspace

int main(int argc, char** argv)
{
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
