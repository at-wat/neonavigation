#!/usr/bin/env python
PACKAGE = "planner_cspace"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gen.add("freq", double_t, 0, "", 4.0, 0.0, 100.0)
gen.add("freq_min", double_t, 0, "", 2.0, 0.0, 100.0)
gen.add("search_timeout_abort", double_t, 0, "", 30.0, 0.0, 100.0)
gen.add("search_range", double_t, 0, "", 0.4, 0.0, 100.0)
gen.add("antialias_start", bool_t, 0, "", False)
gen.add("costmap_watchdog", double_t, 0, "", 0.0, 0.0, 100.0)
gen.add("max_vel", double_t, 0, "", 0.3, 0.0, 100.0)
gen.add("max_ang_vel", double_t, 0, "", 0.6, 0.0, 100.0)
gen.add("min_curve_radius", double_t, 0, "", 0.1, 0.0, 100.0)
gen.add("weight_decel", double_t, 0, "", 50.0, 0.0, 1000.0)
gen.add("weight_backward", double_t, 0, "", 0.9, 0.0, 1000.0)
gen.add("weight_ang_vel", double_t, 0, "", 1.0, 0.0, 1000.0)
gen.add("weight_costmap", double_t, 0, "", 50.0, 0.0, 1000.0)
gen.add("weight_costmap_turn", double_t, 0, "", 0.0, 0.0, 1000.0)
gen.add("weight_costmap_turn_heuristics", double_t, 0, "The weight of the heuristic cost of in-place turning at grid cells with costs", 100.0, 0.0, 1000.0)
gen.add("weight_remembered", double_t, 0, "", 1000.0, 0.0, 1000.0)
gen.add("cost_in_place_turn", double_t, 0, "", 30.0, 0.0, 1000.0)
gen.add("turn_penalty_cost_threshold", int_t, 0, "Penalty costs of in-place turning are not added when the cost of the grid cell is lower than this value", 0, 0, 100)
gen.add("hysteresis_max_dist", double_t, 0, "", 0.1, 0.0, 10.0)
gen.add("hysteresis_expand", double_t, 0, "", 0.1, 0.0, 10.0)
gen.add("weight_hysteresis", double_t, 0, "", 5.0, 0.0, 1000.0)
gen.add("goal_tolerance_lin", double_t, 0, "", 0.05, 0.0, 10.0)
gen.add("goal_tolerance_ang", double_t, 0, "", 0.1, 0.0, 3.14159265359)
gen.add("goal_tolerance_ang_finish", double_t, 0, "", 0.05, 0.0, 3.14159265359)
gen.add("overwrite_cost", bool_t, 0, "", False)
gen.add("hist_ignore_range", double_t, 0, "", 0.6, 0.0, 100.0)
gen.add("hist_ignore_range_max", double_t, 0, "", 1.25, 0.0, 100.0)
gen.add("remember_updates", bool_t, 0, "", False)
gen.add("remember_hit_prob", double_t, 0, "", 0.6, 0.0, 1.0)
gen.add("remember_miss_prob", double_t, 0, "", 0.3, 0.0, 1.0)
gen.add("local_range", double_t, 0, "", 2.5, 0.0, 100.0)
gen.add("longcut_range", double_t, 0, "", 0.0, 0.0, 100.0)
gen.add("esc_range", double_t, 0, "", 0.25, 0.0, 100.0)
gen.add("tolerance_range", double_t, 0, "", 0.25, 0.0, 1.0)
gen.add("tolerance_angle", double_t, 0, "", 0.0, 0.0, 3.14159265359)
gen.add("sw_wait", double_t, 0, "", 2.0, 0.0, 100.0)
gen.add("find_best", bool_t, 0, "", True)
gen.add("force_goal_orientation", bool_t, 0, "", True)
gen.add("temporary_escape", bool_t, 0, "", True)
gen.add("fast_map_update", bool_t, 0, "", False)
gen.add("max_retry_num", int_t, 0, "", -1, -1, 100)
gen.add("keep_a_part_of_previous_path", bool_t, 0, "If true, a part of the previous path is preserved to avoid radical path changes.", False)
gen.add("dist_stop_to_previous_path", double_t, 0, "Valid only when keep_a_part_of_previous_path is true. This should be the same as dist_stop parameter of trajectory_tracker.", 0.1, 0.0, 1.0)
gen.add("trigger_plan_by_costmap_update", bool_t, 0, "", False)

exit(gen.generate(PACKAGE, "planner_cspace", "Planner3D"))
